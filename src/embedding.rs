//! Embedding module for generating text embeddings using OpenAI-compatible APIs.\n//!\n//! This module provides functionality to generate embeddings for text content\n//! using models like \"granite-embedding\" through an OpenAI-compatible API endpoint.\n\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse std::error::Error;\n\nuse crate::config::get_config;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct EmbeddingRequest {\n    model: String,\n    input: String,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct EmbeddingData {\n    embedding: Vec<f32>,\n    index: u32,\n    object: String,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct EmbeddingResponse {\n    data: Vec<EmbeddingData>,\n    model: String,\n    object: String,\n    usage: UsageData,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct UsageData {\n    prompt_tokens: u32,\n    total_tokens: u32,\n}\n\n/// Generate an embedding for the given text using the configured API\n///\n/// # Arguments\n///\n/// * `text` - The text to generate an embedding for\n///\n/// # Returns\n///\n/// * `Result<Vec<f32>, Box<dyn Error>>` - The embedding vector or an error\npub async fn generate_embedding(text: &str) -> Result<Vec<f32>, Box<dyn Error>> {\n    let config = get_config();\n    \n    // Create HTTP client\n    let client = Client::new();\n    \n    // Prepare request\n    let request_body = EmbeddingRequest {\n        model: config.embedding_model().to_string(),\n        input: text.to_string(),\n    };\n    \n    // Send request to API\n    let response = client\n        .post(format!(\"{}/embeddings\", config.openai_api_base()))\n        .header(\"Authorization\", format!(\"Bearer {}\", config.openai_api_key()))\n        .header(\"Content-Type\", \"application/json\")\n        .json(&request_body)\n        .send()\n        .await?;\n    \n    // Check if request was successful\n    if !response.status().is_success() {\n        let error_text = response.text().await?;\n        return Err(format!(\"API request failed: {}\", error_text).into());\n    }\n    \n    // Parse response\n    let embedding_response: EmbeddingResponse = response.json().await?;\n    \n    // Return the first embedding\n    if let Some(embedding_data) = embedding_response.data.first() {\n        Ok(embedding_data.embedding.clone())\n    } else {\n        Err(\"No embedding data in response\".into())\n    }\n}\n\n/// Generate a summary of scraped content using embeddings\n///\n/// # Arguments\n///\n/// * `title` - The title of the page\n/// * `content` - The text content of the page\n///\n/// # Returns\n///\n/// * `Result<String, Box<dyn Error>>` - A summary of the content or an error\npub async fn summarize_content(title: Option<&str>, content: &str) -> Result<String, Box<dyn Error>> {\n    // For now, we'll just return a simple summary\n    // In a more advanced implementation, we could use the embeddings for similarity search\n    // or other NLP tasks\n    \n    let summary = if let Some(title) = title {\n        format!(\"Title: {}\\nContent preview: {}\", title, \n                if content.len() > 200 {\n                    format!(\"{}...\", &content[..200])\n                } else {\n                    content.to_string()\n                })\n    } else {\n        format!(\"Content preview: {}\", \n                if content.len() > 200 {\n                    format!(\"{}...\", &content[..200])\n                } else {\n                    content.to_string()\n                })\n    };\n    \n    Ok(summary)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_generate_embedding() {\n        // This test requires a valid API key and endpoint\n        // For now, we'll just test that the function compiles\n        // In a real test, we would mock the HTTP client\n        let _ = generate_embedding(\"test text\").await;\n    }\n\n    #[tokio::test]\n    async fn test_summarize_content() {\n        let summary = summarize_content(Some(\"Test Title\"), \"This is a test content\").await;\n        assert!(summary.is_ok());\n    }\n}